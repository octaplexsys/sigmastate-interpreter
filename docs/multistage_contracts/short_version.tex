%\documentclass[11pt]{article}
\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\mixname}{ErgoMix\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}
\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}


\title{Multi-Stage Contracts in the UTXO Model}


\author{Alexander Chepurnoy, Amitabh Saxena}
\institute{Ergo Platform \\\email{\{kushti,amitabh123\}@protonmail.ch}}

\maketitle


\begin{abstract}
	\ignore{
		The paper does not describe the system and its properties well. It only gives a short high level overview and then just provides some example smart contracts. The authors should add a proper system overview and a more detailed description of how a contract is deployed and executed. For example, what roles are there in the system and what steps are taken to execute a transaction (e.g. as sequence diagram). It is also not clear what the actual research contributions are. What are the challenges for creating such a system?
		
		Given that the scripts that are specified for future outputs as well as data are not stored on-chain, how can one make sure that all contract participants have the information needed to execute a smart contract?
		}

%Since the advent of blockchains such as Bitcoin and in particular Ethereum, the concept of ``smart contracts'' has gained a lot of attention. 
Smart contract platforms such as Bitcoin and Ethereum allow writing programs that run on a decentralized computer. Bitcoin uses short-lived immutable data structures called UTXOs for data manipulation. Ethereum, on the other hand uses, long-lived mutable data structures called {\em accounts}. UTXOs are easier to handle, less error prone and scale better because the only operation we can do with them  is to create or destroy (i.e., spend) them. The code inside a UTXO is executed only once, when it is spent. Additionally, this code refers to only local context (i.e., it is stateless). In Ethereum's account based system, there is a shared global context which each account can access and modify, thereby causing side affects. 
%Furthermore, Ethereum's language is not decidable and this has its own set of drawbacks. 
However, the benefit of persistent storage offered by accounts makes up for these drawbacks. 
In this work, we describe how to emulate persistent storage in UTXO based systems using a technique called {\em transaction trees}. This allows us to emulate the functionality of account-based systems such as Ethereum without the overhead of accounts. 
We demonstrate this via several examples which include contracts for a Rock-Paper-Scissors game, crowdfunding and an initial coin offering (ICO). The contracts are created in a UTXO based smart contract platform called Ergo that supports transaction trees. 
%
%% An example of This is possible if the underlying scripting language supports {\em transaction trees}
%
%
%% blockchain platform called {\em Ergo} that provides Ethereum-like functionality despite being UTXO-based. 
%This is possible due to a new technique called {\em transaction trees} that can emulate persistent storage in UTXO based systems. We demonstrate this via several examples which include contracts for a Rock-Paper-Scissors game, crowdfunding and an initial coin offering (ICO).

\end{abstract}


\section{Introduction}

Smart contracts were envisioned in 1994 by Nick Szabo~\cite{szabo1997idea}, a legal scholar and cryptographer. He proposed the concept of self-executing contracts written in executable code and stored in a replicated manner on distributed computers that enforced the rules written in the code. 
Bitcoin~\cite{Nak08} can be seen as the first implementation of this concept using a fully decentralized ledger whose contracts primarily pertain to transfer and store of value, i.e., as a currency system. 
Ethereum~\cite{wood2014ethereum} is an example of a general-purpose smart contract platform. 

\ignore{
A useful way of representing a smart contract platform is to consider it as a {\em singleton computer}, where only one single-threaded instance exists in the entire world and everyone can use it for storage and computation by writing code in a language that the computer understands.
Bitcoin's language supports limited types of smart contracts, since its primary design goal was for a currency system. In this way, can think of Bitcoin as an {\em application specific} singleton computer, while Ethereum can be considered a {\em general purpose} singleton computer.
}

%\subsection{Bitcoin Versus Ethereum}
The limited application of Bitcoin allows optimizations focussed on long-term survivability and scalability. Firstly, all data and code is stored in short-lived immutable objects (called UTXOs~\cite{utxo}). A user can execute code inside a UTXO by supplying some input (which may contain additional code). A UTXO is destroyed once its code is executed (i.e., it is spent). Secondly, all computation is performed within a {\em local context}; any code pertaining to a UTXO can only operate on data for that UTXO and does not have access to the global state. 
%Finally, the instruction set is limited enough to guarantee that the language is {\em Turing decidable}. In particular, every program of size $n$ terminates in $\Theta(n)$ steps. 

In contrast, Ethereum follows a different set of design principles in which the code and data is contained in long-lived mutable objects called {\em accounts}. This was done because UTXOs are stateless and do not provide persistent storage. 
Not only can Ethereum code modify data in its own account, but also trigger execution of code in other accounts. Thus, Ethereum code operates over a {\em shared global context} representing all existing accounts. 
%Additionally, Ethereum's contract writing language is Turing complete with a cost component: every instruction incurs a non-refundable cost, called {\em gas}, that must be paid beforehand (any still executing contract is reset to its initial stage once the gas runs out). 
%All these features allow sophisticated contracts. However, they also cause several scalability and security issues, which are still being addressed~\cite{Luu:2016:MSC:2976749.2978309,hackernoon17}. 

%Ethereum followed these principles because of the  belief 
%that 
%Turing completeness are necessary for a general-purpose singleton computer, and that 
%immutable objects are not suitable for smart contracts because they lack persistent storage, and thus, cannot encode Turing complete programs. 

%Firstly, we note that even the most advanced contracts written in Ethereum do not require Turing completeness~\cite{hackernoon16,hackernoon17}. Nor does being Turing complete imply suitability for writing complex contracts. For example, the Rule 110 \cite{Cook_2009,neary2006p} 
%and Conway's Game of Life~\cite{rendell2014turing} 
%cellular automation is Turing complete but impractical for real-world use. 
%Secondly, while UTXOs lack persistent storage, we can achieve the same by propagating data across multiple UTXOs using a technique called {\em transaction trees}. 
%This was used to construct a Turing complete language by emulating Rule-110~\cite{CKM18a}.

The results of~\cite{CKM18a} allow UTXO-based systems to emulate Ethereum-like functionality by reducing the computation to Rule-110~\cite{Cook_2009,neary2006p}. However, such reductions are not very efficient and a more practical solution for the same is desirable. 
In particular, we need higher-level abstractions (instead of Rule-110) that enable UTXO-based systems to efficiently emulate Ethereum functionality and maintain Bitcoin's scalability. 
In this work we describe a technique called {\em transaction trees} that allow writing advanced smart contracts in UTXO based systems. As proof of concept, we implemented such contracts on a UTXO-based platform called Ergo that supports transaction trees.

%, provided that the underlying contract language supports it
\textbf{Context Enrichment.} In Bitcoin and other existing UTXO systems, the context is just the UTXO being processed. In order for a UTXO-based system to support transaction trees, the context must be rich enough to contain at least the entire spending transaction. More formally, 
%main  Ergo is that of enriching the local context. In Bitcoin and other UTXO systems, the context is just the UTXO being processed. However, we can have various levels of local contexts.
%To be more precise, 
for any UTXO based blockchain, we can define the following levels of context, each extending the previous:
\begin{enumerate}
	\item The current UTXO plus the blockchain height and time
	\item The current spending transaction (other inputs and outputs)
	\item The current block's solution.
	\item The current block (other sibling transactions)
\end{enumerate}

%Assume that the scripting language supports writing predicates using the context variables available at that level. 

Any platform at Level 2 and above is suitable for transaction trees. In this regard, Bitcoin operates at Level 1 and Ergo at Level 3. Note that in Level 4 we cannot check validity of transactions independently of other transactions in the block. Hence it is more complex to implement Level 4. 

%supports the first three. 
%Note that we don't go beyond the block because anything other than the current block will require global state access
%However, in order to support this, the underlying language must be capable of encoding predicates about the entire transaction. 



In this work we show via examples how to create efficient Ethereum-like contracts in the UTXO model using transaction trees. 
The examples include a Rock-Paper-Scissors game, an Initial Coin Offering (ICO) campaign and a new primitive called {\em reversible addresses} for securely storing funds. 
%The examples show how to create multi-stage contracts with evolving data and demonstrate how Ergo can cover a majority of use-cases where Ethereum is used.  


\section{Ergo Overview}
\label{ergo-overview}

The Ergo platform is a Level 3 UTXO based blockchain that allows general-purpose smart contracts via a highly expressible language called \langname. 
Since Ergo follows the UTXO based model, all data and code is stored in immutable objects called {\em boxes}. As in Bitcoin, a transaction in Ergo can spend (destroy) multiple boxes and create new ones. 
A box is made of up to ten {\em registers} labelled $R_0, R_1,\ldots R_9$, four of which are mandatory. $R_0$ contains the monetary value, $R_1$ contains the {\em guard script}, $R_2$ contains assets (tokens) and $R_3$ contains a unique identifier of 34 bytes made up of a transaction ID and an output index. The guard script in $R_1$ encodes a spending condition, which must be satisfied for spending the box. Deploying a contract involves creating an unspent box with the relevant \langname code in $R_1$ and populating other registers if necessary. The contract is executed by spending the box. 


Similar to Bitcoin, an \langname program also cannot access the global state and all computation must be done only using a local context. Unlike Bitcoin, this context is quite rich and allows access to the entire spending transaction~\cite{tutorial}. 
In particular, an \langname program defines the spending condition using predicates on the inputs and outputs of the transaction interleaved with Sigma protocols~\cite{Dam10}. Thus, an \langname program can enforce the spending transaction's structure (such as requiring that assets are transferable only to a certain address). Additionally, the program can require the spender to prove knowledge of the discrete logarithm of some public value using a protocol called \texttt{proveDlog}, which is based on the Schnorr identification scheme~\cite{Dam10}. All public keys (such as \texttt{alice} and \texttt{bob}) in the following sections are of type \texttt{proveDlog}. Similar to Bitcoin, a Pay-to-Script-Hash (P2SH) address in Ergo contains the hash of a script that must be provided when spending from that address. The script encodes the actual spending condition. Ergo also supports Pay-to-Script (P2S) address, where the actual script is encoded in the address. 

 
 One useful feature of Ethereum is the ability to store and access a large amount of data, which Ergo also provides.
 However, Ergo contracts do not store the actual data in the blockchain. Rather, the data is stored off chain and a short digest is stored in the blockchain. A user wishing to access or modify this data must provide correct proofs of (non)-existence or modification for this digest, as in the ICO example of Section~\ref{ico}. 

\section{Transaction Trees}

A powerful feature of \langname is the ability to specify the spending transaction's structure in a fine-grained manner. 
Among the many things we can specify, the important ones are: (1) the number of input and output boxes, (2) the value of any box, and (3) the guarding script of any box. This allows us to create {\em transaction trees}, where the contract in an input box requires an output box to contain some predefined contract, thereby ensuring that only a certain sequence of contracts are possible. 
We will use this to convert an Ethereum-style long-lived contract into multi-stage contracts in the UTXO model, where each stage encodes data and code to be carried over to the next stage. 

\textbf{Transaction Chains:} Before describing transaction trees, we describe a simpler primitive called transaction chains. A transaction chain is used for creating a multi-stage protocol whose code does not contain loops or `if' statements. A transaction chain is created as follows:
\begin{enumerate}
	\item Represent an Ethereum contract's execution using $n$ sequential steps, where each step represents a transaction that modifies its state.
The states before and after a transaction are the start and end nodes respectively of a directed graph, with the transaction as the edge joining them. 
	As an example, a 3-stage contract, such as the ICO example of Section~\ref{ico} is represented as:
	
	\begin{tikzpicture}
	
	\tikzset{vertex/.style = {shape=circle,draw,minimum size=1.5em}}
	\tikzset{edge/.style = {->,> = latex'}}
	% vertices
	\node[vertex] (a) at  (0,0) {$s_1$};
	\node[vertex] (b) at  (2,0) {$s_2$};
	\node[vertex] (c) at  (4,0) {$s_3$};
	%edges
	\draw[edge] (a) to (b);
	\draw[edge] (b) to (c);
	
	\end{tikzpicture}
	
	The states contain data and the code that was executed in the transaction.
	\item Hardwire state $n$'s code and data inside state $n-1$'s code. Then require the code of state $n-1$ to output a box containing state $n$'s code and data. An example is given in the following pseudocode:
	\begin{verbatim}
	out.propositionBytes == state_n_code &&  
	out.R4[Int].get == SELF.R4[Int].get // ensure data is propagated
	\end{verbatim}
	
	The above code uses the field \texttt{propositionBytes} of a box, which contains the binary representation of its guard script as collection of bytes.
	
	
	\item Repeat Step 2 by replacing $(n, n-1)$ by $(n-1, n-2)$ while $n > 2$.
\end{enumerate}

To avoid code size increase at each iteration, we should ideally work with hashes, as in \texttt{hash(out.propositionBytes) == state\_n\_code\_hash}. However, for clarity of presentation, we will skip this optimization.
 
\textbf{Transaction Trees:} A transaction tree is an extension of transaction chains where the code can contain `if' statements and {\em simple loops}, i.e., where some start and end nodes are the same. The following figure illustrates a transaction tree.

\begin{tikzpicture}

\tikzset{vertex/.style = {shape=circle,draw,minimum size=1.5em}}
\tikzset{edge/.style = {->,> = latex'}}
% vertices
\node[vertex] (a) at  (0,0) {$s_1$};
\node[vertex] (b) at  (2,0) {$s_2$};
\node[vertex] (c) at  (4,1) {$s_3$};
\node[vertex] (d) at  (4,-1) {$s_4$};
%edges
\draw[edge] (a) to (b);
\draw[edge] (b) to (c);
\draw[edge] (b) to (d);
\draw[black,thin,->] (a.80) arc (0:264:4mm);

\end{tikzpicture}

An `if' statement is handled using the following pseudocode. 

\begin{verbatim}
    if (condition) { out.propositionBytes == state_3_code }
    else { out.propositionBytes == state_4_code }
\end{verbatim}

A simple loop is a special case of the `if' statement:
\begin{verbatim}
    if (condition) { out.propositionBytes == state_2_code }
    else { out.propositionBytes == SELF.propositionBytes }
\end{verbatim}

%To handle this case, ...

\textbf{Transaction graphs:} Ergo supports a more advanced technique called {\em transaction graphs}, where cycles are allowed in contract references, as shown below. %and two contracts can refer to each other

	\begin{tikzpicture}
	
	\tikzset{vertex/.style = {shape=circle,draw,minimum size=1.5em}}
	\tikzset{edge/.style = {->,> = latex'}}
	% vertices
	\node[vertex] (a) at  (0,-1) {$s_1$};
	\node[vertex] (b) at  (2,0) {$s_2$};
	\node[vertex] (c) at  (4,0) {$s_3$};
	\node[vertex] (d) at  (2,-2) {$s_4$};
	\node[vertex] (e) at  (4,-2) {$s_5$};
	%edges
	\draw[edge] (a) to (b);
	\draw[edge] (b) to (c);
	\draw[edge] (d) to (a);
	\draw[edge] (b) to (d);
	\draw[edge] (d) to (e);
	\draw[edge] (e) to (b);
\draw[black,thin,->] (a.80) arc (0:264:4mm);
		
	\end{tikzpicture}

Discussion of such contracts is beyond the scope of this work and we refer the reader to~\cite[Section 3.3.3]{advtutorial} for an example of such a contract. All the examples in this paper are based on transaction trees.

\section{Multi-Stage Contracts}
%This section contains examples of multi-stage contracts using transaction trees.
\subsection{Reversible Addresses}
\label{reversible}

% idea, originally proposed for Bitcoin~\cite{raddress},

An example of multi-stage contract is a {\em reversible address}, which has anti-theft features in the following sense: any funds sent to a reversible address can only be spent in way that allows payments to be reversed for a certain time. To motivate this feature, consider managing the hot-wallet of an exchange or mining pool used for handling customer withdraws. A hot-wallet is an address for which the private key is stored on the server. Such addresses are necessary for facilitating automated withdrawals. Being a hot-wallet, its private key is susceptible to compromise and funds being stolen. 
We want to ensure that we are able to recover any stolen funds in the event of such a compromise, provided that the breach is discovered within, say, 24 hours of the first unauthorized withdraw. %This can be achieved using reversible addresses.

Assume that \texttt{alice} is the public key of the hot-wallet and \texttt{carol} is the public key of the trusted party. The private key of \texttt{carol} will be needed for reversing payments and must be stored offline. Let \texttt{b} be the estimated number of blocks in a 24 hour period. 
Let Bob with public key \texttt{bob} be a customer wishing to withdraw funds, which will be paid out by the hot-wallet. 

In Ethereum, we can do this by sending funds to an account having with a contract $C_{b}$ that allows \texttt{carol} to withdraw funds at least \texttt{b} blocks and after that they can only be withdrawn by \texttt{bob}. We could use the same account (contract instance) for multiple withdraws by Bob, but the optimal way is to have a new account for each withdraw, emulating the UTXO model. The funds for this must also come from another account with a contract $C_{a}$ that ensure that withdraw can only be done to a contract with the structure of $C_{b}$. 

In Ergo, this is done by a two-stage protocol, where the second stage implements $C_{b}$ and the first stage implements $C_{a}$. 
The following script called \texttt{withdrawScript} implements the second stage. This will be the guarding script of the hot-wallet's withdraw transaction paying to \texttt{bob}.

\small{
	\begin{verbatim}
	val bob = SELF.R4[SigmaProp].get    // public key of customer withdrawing
	val bobDeadline = SELF.R5[Int].get  // max locking height
	(bob && HEIGHT > bobDeadline) || (carol && HEIGHT <= bobDeadline)
	\end{verbatim}
}

This above script is referenced in the first stage script given next. 
%Let \texttt{feeScript} be the script paying fee and \texttt{maxFee} be the maximum allowed fee. 

\small{
	\begin{verbatim}
	val isChange = {(b:Box) => b.propositionBytes == SELF.propositionBytes}
	val isWithdraw = {(b:Box) => 
	    b.R5[Int].get >= HEIGHT + blocksIn24h && 
	    b.propositionBytes == withdrawScript
	}
	alice && OUTPUTS.forall({(b:Box) => isChange(b) || isWithdraw(b)})
	\end{verbatim}
}

The reversible address is the P2SH address of the above script. Any funds sent to this address are subject to the withdraw rules that we desire.
%The sender (\texttt{alice}) must ensure that register $R_4$ of the new box contains \texttt{bob}. 
In the normal case, Bob will spend the box after roughly \texttt{blocksIn24h} blocks. If an unauthorized transaction from the hot-wallet is detected, an abort procedure is triggered using the private key of \texttt{carol} and funds in any unspent boxes sent from the hot-wallet are diverted to a secure address. %Additionally, boxes currently controlled by \texttt{alice} also need to be sent secure addresses. 
Note that the trusted party (\texttt{carol}) is bound to the hot-wallet address. A new address is needed for a different trusted party. 

Although such addresses are designed for securing hot-wallet funds, the may have other applications. One example is for automated-release escrow payments in online shopping, where \texttt{carol} can be the public key of any mutually agreed adjudicating party. 


%For simplicity, our code often refers to another script directly, as in: 
%\begin{verbatim}
%    box.propositionBytes = script
%\end{verbatim}
%   
%In practice, however, we would first compute \texttt{scriptHash}, the hash of \texttt{script} and rewrite the above code as: 
%\begin{verbatim}
%    blake2b256(box.propositionBytes) == scriptHash
%\end{verbatim}

\subsection{Rock-Paper-Scissors Game}
\label{rps}

Our next example of a multi-stage contract is the Rock-Paper-Scissors game, which is often used to introduce Ethereum~\cite{rps15}.
%to beginners, since it captures many important aspects such as provable fairness, workflow enforcement and adaptive security~\cite{rps15}. 
The game is played between two players, Alice and Bob. Each player chooses a secret independently and the game is decided after the secrets are revealed. 
Let $a, b\in \mathbb{Z}_3$ be the secrets of Alice, Bob respectively, with the understanding that (0, 1, 2) represent (rock, paper, scissors). If $a = b$ then the game is a draw, otherwise if $a-b \in \{1, -2\}$ then Alice wins else Bob wins. 

The first party to reveal the secret has a disadvantage, since the other party can adaptively choose and win. In the real world, both parties reveal their secrets simultaneously to prevent this. In the virtual world, however, this cannot be enforced. Hence this attack must be handled using {\em cryptographic commitments}, where the first party, Alice, does not initially reveal her secret, but rather only a commitment to that secret. 
The modified game using commitments is as follows:

\begin{enumerate}
	\item Alice commits to her secret $a$ by inputting her commitment $c = Comm(a)$.
	\item Bob inputs his public value $b$. At this stage, Alice knows if she won or lost.
	\item Alice opens her commitment and reveals $a$, after which the winner is decided.
\end{enumerate}

This works fine assuming that Alice is {\em well-behaved}, i.e., she always opens her commitment irrespective of whether she won or lost. In the real world, however, we also need to consider the possibility that Alice never opens her commitment. 
Border cases such as these make smart contracts quite tricky, because once deployed, it is not possible to add ``bug-fixes'' to them. In this example, we must penalize Alice (with a loss) if she does not open her commitment within some stipulated time.

The complete game is coded in \langname in two stages. In the first stage, Alice creates a {\em start-game} box that encodes her game rules. In the second stage, Bob spends the start-game box and creates two {\em end-game} boxes spendable by the winner. These new boxes indicate that the game has ended.

To start the game, Alice decides a game amount $x$ (of Ergo's primary token), which each player must contribute. She then selects a secret $s$ and computes a commitment $c=H(a||s)$ to $a$. Finally, she locks up $x$ tokens along with her commitment $c$ inside the start-game box protected by the following script:
\small{
	\begin{verbatim}
OUTPUTS.forall(
  {(out:Box) =>
    val b = out.R4[Byte].get
    val bobDeadline = out.R6[Int].get
    bobDeadline >= HEIGHT+30 && out.value >= SELF.value &&
    (b == 0 || b == 1 || b == 2) && 
    out.propositionBytes == outScript
  }
) && OUTPUTS.size == 2 && OUTPUTS(0).R7[SigmaProp].get == alice &&
OUTPUTS(0).R4[Byte].get == OUTPUTS(1).R4[Byte].get // same b
	\end{verbatim}
}


The above code requires that the spending transaction must create exactly two outputs, one paying to each player in the event of a draw or both paying to the winner otherwise. In particular, the code requires that (1) register $R_7$ of the first output must contain Alice's public key (for use in the draw scenario), (2) register $R_4$ of each output must contain Bob's choice, and (3) each output must contain at least $x$ tokens protected by \texttt{outScript}, which is given below:

\small{
\begin{verbatim}
val s = getVar[Coll[Byte]](0).get  // Alice's secret byte string s
val a = getVar[Byte](1).get  // Alice's secret choice a
val b = SELF.R4[Byte].get    // Bob's public choice b
val bob = SELF.R5[SigmaProp].get // Bob's public key
val bobDeadline = SELF.R6[Int].get // after this, Bob wins by default
val drawPubKey = SELF.R7[SigmaProp].get
val valid_a = (a == 0 || a == 1 || a == 2) 
val validCommitment = blake2b256(s ++ Coll(a)) == c   
val validAliceChoice = valid_a && validAliceChoice
val aliceWins = (a - b) == 1 || (a - b) == -2
val receiver = if (a == b) drawPubKey else (if (aliceWins) alice else bob)
(bob && HEIGHT > bobDeadline) || (receiver && validAliceChoice)
\end{verbatim}
}


The above code protects the two end-game boxes that Bob generates. The condition \texttt{(bob \&\& HEIGHT > bobDeadline)} guarantees that if Alice does not open her commitment before a certain deadline, then Bob automatically wins. 
Note that Bob has to ensure that $R_7$ of the second output contains his public key. Additionally, he must ensure that $R_5$ of both outputs contains his public key (see below). We don't encode these conditions because if Bob doesn't follow the protocol, he will automatically lose.
\subsection{Initial Coin Offering}
\label{ico}

Another popular use-case of Ethereum is an Initial Coin Offering (ICO) contract. %, possibly implementing the ERC-20 standard~\cite{erc20} 
An ICO mirrors an Initial Public Offering (IPO) and provides a mechanism for a project to collect funding in some tokens and then issue ``shares'' (in the form of some other tokens) to investors. Generally, an ICO comprises of 3 stages:
\begin{enumerate}
	\item {\em Funding:} During this period, investors are allowed to fund the project.
	\item {\em Issuance:} A new asset token is created and issued to investors.
	\item {\em Withdrawal:} Investors can withdraw their newly issued tokens. 
\end{enumerate}

Consequently, our ICO consists of 3 contracts, one for each stage such that one stage references the next. 
%Compared to the previous examples, the contract are quite complex since they involve multiple parties. 
The number of investors may run into thousands, and the naive solution would store this data in the contract, as in the ERC-20 standard~\cite{erc20}. 
Unlike Ethereum, Ergo does not permit storing large datasets in a contract. Rather, we store only a 40-bytes header of (a key, value) dictionary, that is authenticated like a Merkle tree~\cite{RMCI17}. To access some elements in the dictionary, or to modify it, a spending transaction should provide lookup or modification proofs. This allows a contract to authenticate large datasets using very little storage and memory. 

\textbf{Funding:} 
The project initiates the ICO by creating a box with the guard script given below. The box also contains a authenticating value for an empty dictionary of (investor, balance) pairs in $R_5$, where investor is the hash of a script that will guard the box with the withdrawn tokens (once the funding period ends). 

\small{\begin{verbatim}
	val selfIndexIsZero = INPUTS(0).id == SELF.id
	val proof = getVar[Coll[Byte]](1).get
	val toAdd = INPUTS.slice(1, INPUTS.size).map({(b: Box) =>
	    val pk = b.R4[Coll[Byte]].get
	    val value = longToByteArray(b.value)
	    (pk, value)
	})
	val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get
	val expectedTree = OUTPUTS(0).R5[AvlTree].get
	val selfOutputCorrect = 
	  if (HEIGHT < 2000) OUTPUTS(0).propositionBytes == SELF.propositionBytes
	  else OUTPUTS(0).propositionBytes == issuanceScript 
	val outputsCorrect = OUTPUTS.size == 1 && selfOutputCorrect
	
	selfIndexIsZero && outputsCorrect && modifiedTree == expectedTree
	\end{verbatim}
}

%The \texttt{issuanceScript} variable contains code of the issuance stage script.

The first funding transaction spends this box and creates a box with the same script and updated data. Further funding transactions spend the box created from the previous funding transaction. The box checks that it is first input of each funding transaction, which must have other inputs belonging to investors. The investor inputs contain a hash of the withdraw script in register $R_4$. 
The script also checks (via proofs) that hashes and monetary values of the investing inputs are correctly added to the dictionary of the new box, which must be only output with the correct amount of ergs (we ignore fee in this example). 
In this stage, which lasts at least till height 2,000, withdraws are not permitted and ergs can only be put into the project. 
The first transaction with height of 2,000 or more should keep the same data but change the output's script called \texttt{issuanceScript} described next.

\textbf{Issuance:}
This stage requires only one transaction to get to the next stage (the withdrawal stage). The spending transactions makes the following modifications. Firstly, it changes the list of allowed operations on the dictionary from ``inserts only'' to ``removals only''.
Secondly, the contract checks that the proper amount of ICO tokens are issued. In Ergo, each transaction can issue at most one new kind of token, with the (unique) identifier of the first input box. The issuance contract checks that a new token is issued with amount equal to the nano-ergs collected till now. Thirdly, the contract checks that a spending transaction is indeed re-creating the box with the guard script corresponding to the next stage, the withdrawal stage. 
Finally, the contract checks that the spending transaction has 2 outputs (one for the project tokens and one for the ergs withdrawn by the project).
The complete script is given below.
\small{
	\begin{verbatim}
	val openTree = SELF.R5[AvlTree].get
	val closedTree = OUTPUTS(0).R5[AvlTree].get
	val correctDigest = openTree.digest == closedTree.digest
	val correctKeyLength = openTree.keyLength == closedTree.keyLength
	val removeOnlyTree = closedTree.enabledOperations == 4
	val correctValue = openTree.valueLengthOpt == closedTree.valueLengthOpt
	val tokenId: Coll[Byte] = INPUTS(0).id
	val tokenIssued = OUTPUTS(0).tokens(0)._2
	val correctTokenNumber = OUTPUTS(0).tokens.size == 1 && 
	                         OUTPUTS(1).tokens.size == 0
	val correctTokenIssued = SELF.value == tokenIssued
	val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId &&
	                     OUTPUTS(0).tokens(0)._1 == tokenId
	val valuePreserved = OUTPUTS.size == 2 && correctTokenNumber && 
	                     correctTokenIssued && correctTokenId
	val stateChanged = OUTPUTS(0).propositionBytes == withdrawScript
	val treeIsCorrect = correctDigest && correctValue && 
	                    correctKeyLength && removeOnlyTree
	
	projectPubKey && treeIsCorrect && valuePreserved && stateChanged
	\end{verbatim}
}


\textbf{Withdrawal:}
Investors are now allowed to withdraw ICO tokens under a guard script whose hash is stored in the dictionary. Withdraws are done in batches of $N$. A withdrawing transaction, thus, has $N + 1$ outputs; the first output carries over the withdrawal sub-contract and balance tokens, and the remaining $N$ outputs have guard scripts and token values as per the dictionary. The contract requires two proofs for the dictionary elements: one proving that values to be withdrawn are indeed in the dictionary, and the second proving that the resulting dictionary does not have the withdrawn values. The complete script called \texttt{withdrawScript} is given below
\small{
	\begin{verbatim}
	val removeProof = getVar[Coll[Byte]](2).get
	val lookupProof = getVar[Coll[Byte]](3).get
	val withdrawIndexes = getVar[Coll[Int]](4).get
	val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get
	val withdrawals = withdrawIndexes.map({(idx: Int) =>
	    val b = OUTPUTS(idx)
	    if (b.tokens(0)._1 == tokenId) 
	       (blake2b256(b.propositionBytes), b.tokens(0)._2)
	    else 
	       (blake2b256(b.propositionBytes), 0L)
	})
	val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) => t._2})
	val total = withdrawValues.fold(0L, {(l1: Long, l2: Long) => l1 + l2 })
	val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) => t._1})
	val initialTree = SELF.R5[AvlTree].get
	val removedValues = initialTree.getMany(toRemove, lookupProof).map(
	    {(o: Option[Coll[Byte]]) => byteArrayToLong(o.get)}
	)
	val valuesCorrect = removedValues == withdrawValues
	val modifiedTree = initialTree.remove(toRemove, removeProof).get
	val outTreeCorrect = OUTPUTS(0).R5[AvlTree].get == modifiedTree
	val selfTokenCorrect = SELF.tokens(0)._1 == tokenId
	val outTokenCorrect = OUTPUTS(0).tokens(0)._1 == tokenId
	val outTokenCorrectAmt = OUTPUTS(0).tokens(0)._2 + total == SELF.tokens(0)._2
	val tokenPreserved = selfTokenCorrect && outTokenCorrect && outTokenCorrectAmt
	val selfOutputCorrect = OUTPUTS(0).propositionBytes == SELF.propositionBytes
	
	outTreeCorrect && valuesCorrect && selfOutputCorrect && tokensPreserved
	\end{verbatim}
}

Note that the above ICO example contains many simplifications. For instance, we don't consider fee when spending the project box. Additionally, the project does not self-destruct after the withdraw stage. We refer the reader to~\cite{ico-blog} for the full example.

\section{Conclusion}

We gave examples demonstrating that, despite being UTXO-based, Ergo can support complex multi-stage contracts found in Ethereum. In particular, we described:

\begin{enumerate}
	\item A Rock-Papers-Scissors game with provable fairness (Section~\ref{rps}).
	\item Reversible Addresses having anti-theft features (Section~\ref{reversible}).
	\item A full featured ICO that accepts funding in ergs (Section~\ref{ico}). 

\end{enumerate}


The examples used the idea of {\em transaction trees} to emulate persistent storage by linking several UTXOs containing small pieces of code to form a large multi-stage protocol. 
We refer the reader to \langname repository and tutorials~\cite{tutorial,advtutorial} for additional examples of multi-stage contracts, including a Local Exchange Trading Systems (LETS), non-interactive mixing, atomic swaps and many more.

\bibliographystyle{unsrt}
\bibliography{main}

\end{document}